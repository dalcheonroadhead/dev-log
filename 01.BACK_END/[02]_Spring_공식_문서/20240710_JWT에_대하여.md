# JWT에 대하여

> 목차
>
> 1. JWT란 무엇인가? (일반 토큰과 비교했을 때, JWT의 차별점)
> 2. JWT의 구조는 어떻게 되는가? 
> 3. JWT를 이용한 토큰 인증 방식의 과정 
> 4. JWT 토큰 인증 방식이 신뢰성을 가지는 이유 

## 1. JWT란 무엇인가? 

기본적인 토큰 인증 방식을 따르고, 거기서 토큰 자체를 강화한 방식이라 생각하면 된다. 원래의 토큰 인증 기반에서 요청자가 보내온 ID/PW 가 DB에 존재하면 (우리 회원이 맞으면) 그 요청자에게 자신들의 API를 쓸 수 있는 허가증인 토큰을 전해줬었다. 
![image-20240313213753190](https://github.com/dalcheonroadhead/Theory-study/assets/102154788/8f5bc05b-12dd-4645-92ca-455dc644c652)
![image-20240313213805761](https://github.com/dalcheonroadhead/Theory-study/assets/102154788/5a9c3cd7-fc70-496d-b09d-fbd2ff823599)



여기서 더해 JWT의 경우 토큰을 만들 때, 사용자의 정보(간단한 개인정보 등 +@)를  암호화하여 만든다. (암호화에는 BASE64 URL-safe Encode를 쓴다. )  거기에 더해 해당 토큰이 위변조 될 것을 대비해 전자 서명까지 인코딩된 정보 뒤에 붙여 넣는다. (자세한 구조는 후술하겠다.) 이렇게 되면 무엇이 좋을까? 아까 토큰 자체가 사용자에 대한 개인정보라고 하였다. 따라서 해당 인증 절차 이후 사용자가 Header에 JWT를 넣어 API 요청을 하는 경우를 고려해보자. 자신의 개인정보에 관한 간단한 요청일 경우, 서버에서 JWT 자체를 서버의 Key로 디코딩 하여 원하는 정보를 꺼내 다시 반환 할 수 있다. (DB를 안가도 된다.) 자세한 장점 또한 뒤에서 더 말하겠다 . 
일단 JWT의 구조를 한번 보자. 

## 2. JWT의 구조는 어떻게 되는가? 
![image-20240313215406199](https://github.com/dalcheonroadhead/Theory-study/assets/102154788/e2d04d32-248f-4086-8f1d-5f8a3999bba3)



하나씩 살펴보자! 

- Header 
  header부분에는 JWT의 타입과, 
  JWT 토큰 위변조 방지를 위한 전자 서명 만들 때, 사용된 해시 알고리즘이 무엇인지 적혀있다. 

- Payload
  아까 1번에서 말했던 사용자에 대한 간단한 개인정보가 들어있다. 해당 정보들이 BASE64-URL-safe Encode를 통해 암호화된 상태이다. 그 내용을 복호화 하면 위와 같은 JSON 형태로 바꿀 수 있다.

- Signiture

  인코딩된 header, 인코딩된 payload, server가 가지고 있는 secret-key를 Header에 표기된 해쉬 알고리즘에 넣어서 나온 값이다. 우리는 이 값을 통해 요청으로 들어온 JWT가 위변조 되었는지 아닌지를 체크할 수 있다. (어떻게 위변조 체크를 하는지는 뒤에서 알아보자.)

  

 ## 3. JWT를 이용한 토큰 인증 방식의 과정
![image-20240313221626069](https://github.com/dalcheonroadhead/Theory-study/assets/102154788/80ce08b1-d43b-46f3-8e12-765f717b1007)



기존 토큰 인증 방식과 큰 틀은 똑같다. 클라이언트가 요청을 보내고, 진짜 우리 회원인지 확인 후 맞으면 토큰을 보낸다. 다만 이 때 보내는 토큰이 Access Token(이하 AT), Refresh Token(이하 RT)로 두 개이다. AT는 우리가 쓰던 그대로 Server에 API 요청을 하기 위해 쓰인다. RT는 언제 쓰일까? 

토큰 인증 방식의 취약점으로 항상 대두되었던 것이, 중간에 AT를 탈취 당하면 아무 상관없는 제 3자도 원 주인의 개인정보에 기반한 API를 가져올 수 있다는 것이었다. 거기에 대한 보완점으로 JWT가 내놓은 대답은 AT 자체에 수명을 짧게 두는 것이다. 이렇게 된다면 누가 AT를 탈취하여도 금방 만료되어 쓰지 못하게 된다. 
  그러면 우리의 선량한 사용자도 AT 수명이 다 할때마다 원래의 로그인 절차를 다시 밟아야 하는가? 현재 많은 서비스의 AT 수명은 한 시간인데, 이렇다면 우리는 코테 문제를 풀다가 한 시간이 지나버렸을 경우, 제출버튼을 눌렀는데, 로그인 창으로 가버려서 코딩 내역을 다 날려버릴 것이다! 
  또 이 짧은 AT의 수명에 대한 대안점으로 RT가 등장하였다. RT 또한 JWT 토큰인데, 오직 AT를 재발급 하는 용도로만 쓴다. RT의 경우 사용자 정보와 같이 DB에 저장하는 경우가 많다. 따라서 사용자가 RT를 통해 재발급 요청을 하면, Server는 해당 사용자 레코드에 적힌 RT와 대조하여 일치하면 AT를 다시 제공해준다. 이렇게 RT는 AT가 만료된 경우에만 요청에 등장하기 때문에 간헐적이라 탈취가 쉽지 않을 것이다. RT의 평균 수명은 한달 ~ 두달 정도로 넉넉하다. 

![image-20240313221640737](https://github.com/dalcheonroadhead/Theory-study/assets/102154788/5da48d26-6890-4c95-ad3a-4722ae8e2a4c)


## 4. JWT 토큰 인증 방식이 신뢰성을 가지는 이유 

JWT 토큰 인증 방식이 신뢰성을 가지는 이유는 JWT 토큰의 위변조 여부를 Server에서 가려낼 수 있기 때문이다.  어떻게 가려낼까? JWT 토큰의 경우 크게 3가지 부분으로 나눌 수 있었다. 
A (인코딩된 Header) + B (인코딩된 Payload) + C(전자서명) 
C의 전자서명은 해당 A, B + server에 존재하는 Secret Key를 해쉬 알고리즘으로 암호화 했을 때의 반환값이었다. 

> C를 재현할 수 있을까? 

있다. server에 요청이 들어왔다면 헤더에 JWT(A+B+C) 도 들어왔다는 것이기 때문에 C를 만들 수 있는 매개 변수가 모두 존재한다. 

> HSA256(A,B,server-key) = C  

자, 만약에 나쁜 마음을 먹은 누군가가 JWT를 탈취해서 A나 B 중 정보를 위변조 했다고 치자. 만약 위변조 한대로, 값이 들어와서 Server에서 쓰인다면, DB 자체를 헤집어서 난장판으로 만들 가능성도 있다. 따라서 정말 위험하다. 
  누군가 payload를 위조해서 JWT가 다음과 같이 변했다고 하자 

> JWT2(A + B' + C) 

이걸로 전자서명을 재현하려고 들면, HSA256(A,B',server-key)로 들어가게 될 것이고, 인수가 달라지니 반환값도 완전히 달라질 것이다. HSA256(A,B',server-key) = %%%%% 
**이렇게 C의 전자서명 값을 들어온 JWT로 재현하려 했을 때, 되지 않는 다면, 해당 JWT는 위변조 된 것으로 판단할 수 있다.**

이런 식으로 JWT는 위변조에 강하기에 JWT 토큰 인증 방식은 일반 토큰 인증 방식보다 신뢰성을 가진다. 
