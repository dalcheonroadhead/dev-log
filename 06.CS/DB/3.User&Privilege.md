[toc]

# 0. MYSQL의 사용자 관리 전개도

![image-20250305202739327](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/User&Privilege/image-20250305202739327.png)

# 1. 사용자 식별

## (1) MySQL만의 사용자 식별 방법

다른 DBMS랑 다르게 MySQL은 `사용자 계정 이름` + `@` + `사용자의 접속지점(실행 클라이언트 호스트명 or IP 주소)` 로 사용자를 식별함.

ex) 예시

| 사용자 계정       |
| ----------------- |
| 전수민@12.0.0.1   |
| 전수민@%          |
| 김대영@localhost  |
| 정민호@sub_net123 |
| 관리자@%          |

마지막의 관리자 처럼 뒤에 접속 지점이 `%`로 되어있는 것은 접속 지점이 어디이든 상관 없이 접속할 수 있음을 의미한다. 반면 맨 첫 계정인, `전수민@12.0.0.1`은 전수민이란 계정은 오로지 `12.0.0.1`에서만 접속할 수 있음을 의미한다.

## (2) 그럼  계정 이름은 같으나, 접속 지점 명시가 여러 개인 경우?

위의 사진 표의 첫 두 줄이 딱 그 상황이다.

**My SQL은 현 사용자 접속 지점에서 유효하게 로그인 할 수 있는 계정이 2개일 경우, 접속 지점 범위가 좁은 계정@호스트명 으로 먼저 접속 시도한다.** 다음 예시를 보자.

| 계정            | 비밀번호 |
| --------------- | -------- |
| 전수민@12.0.0.1 | 123      |
| 전수민@%        | abc      |

### a. 만약 사용자가 12.0.0.1이란 주소에서  아이디: `전수민`, 비번:`abc`로 접속 시도할 경우

계속해서 접속 실패가 뜬다. 따라서 이름이 동일하며 호스트명이 다른 계정 생성에 주의 해야 한다.

### b. 만약 사용자가 12.0.0.1이 아닌 곳에서 아이디 `전수민`, 비번: `abc`로 접속 시도할 경우

mySQL이 먼저 계정 `전수민@12.0.0.1`를 확인했지만, 현 주소지에서 접속 가능한 계정이 아님. 따라서 이 계정은 거르고 다음 더 큰 주소지를 확인 `전수민@%`는 현 접속 지점에서 유효하게 로그인 할 수 있는 계정이다. 따라서 비번 일치 여부를 본다.  현재는 비번도 맞음으로, 접속이 된다.

# 2. 사용자 계정 관리

## (1) 계정 종류

- 일반 계정 
- 시스템 계정

## (2) 시스템 계정이 할 수 있는 일

- 일반 계정의 생애주기 관리 + 권한 부여 및 제거
- 다른 세션(응용 서버와의 Connection), 그 세션이 실행 중인 쿼리 강제 종료
- 스토어드 프로그램 생성 시 DEFINER를 타 사용자로 설정[^스토어드 프로그램이란?]

## (3) 계정 생성 시 필요 사항

- 계정 인증 방식과 비밀번호
- 비밀번호 관리 옵션 ( 비밀번호 유효 기간, 비밀번호 변경 이력이 들고 있을 비밀번호 개수, 비밀번호 재사용 불가 기간)
- 계정의 기본 역할
- SSL 터널링 옵션[^SSL]
- 계정 잠금 여부

> 생성 시 필요사항에 대한 구체적 설명은 realMySQL 책에 잘 나와 있고, 그냥 읽으면 그런가보다 하고 넘어가는 내용이라 생략 합니다.

# 3. 비밀번호 관리

비밀번호 생성 수준을 관리할 수 있다.

- Low: 비밀번호 길이만 검증
- MEDIUM: 비밀번호 길이를 검증하며, 숫자와 대소문자, 특수문자 배합을 검증
- STONG:  MEDIUM LEVEL + 금칙어 포함 여부 검증

> 나머지 금칙어 파일 생성 및 설정 관련해서는 책에 가이드가 잘 나와 있어 생략

## (1) 이중 비밀번호

영어로는 DUAL PASSWORD 이다. 여기서 헷갈리면 안되는 것이 **직렬적으로 비밀번호 인증을 2번 거친다는 것이 아니라, 병렬적으로 비밀번호 2개 중 하나로만 인증하면 된다.**라는 말이다. 

![image-20250305194011116](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/User&Privilege/image-20250305194011116.png)

### a. 필요 이유

보안에 더 안 좋을 거 같은데, 왜 이럴까. 
이유는 **비번을 하나만 직렬적으로 뒀을 경우, On-Service 상황에서 비번 교체를 못한다.**
Spring 서버 실행 중인 도중에 연결된 DB의 비번을 바꿨다고 해보자. Spring 서버에서 Mysql 비번이 틀리면, JPA가 JPQL을 SQL로 변환해서 DB로 쏠려고 할 때 쏘지 못함. (연결 끊어짐) => Connection Session이 끊어지고, 모든 서비스가 사용불가 상태가 됨. 
반면 **둘 중 하나로 되면 from Old Password to New password**로 바꿀 수 있다.

### b. 비밀번호 갈자고 명령 떨어졌을 때 우리가 해야하는 거

MySQL에서는 메인 비밀번호와 서브 비밀번호가 존재함.

```sql
ALTER USER `root@localhost` IDENIFIED BY 'new_password' RETAIN CURRENT PASSWORD;
```

라고 하면 지금 메인 비밀번호는 서브로 가고, 새로 설정한 `new_password`가 메인 비밀번호가 된다. 이제 백엔드 팀에 알려서 비번 교체 작업 하라고 하면 됨. 

# 4. 권한 (Privilege)

## (1) 권한의 종류

- 정적 권한 : MySQL이 처음부터 기본적으로 제공하는 권한, 미리 정의된 고정된 권한임. 
  정적 권한은 다시 글로벌 권한과 객체 권한으로 나뉜다.
  - 글로벌 권한:  범 DB, 테이블 적인 권한, 파일 관리, 권한 관리, 유저 생성 등
  - 객체 권한: 테이블, DB에 대한 CRUD 권한
- 동적 권한: My_SQL 8.0부터 도입된 새로운 권한 시스템 
  - 백업 수행 권한
  - 바이너리 로그 권한
  - 리플리케이션 관련 권한
  - MySQL 감사 로그 관리 권한

# 5. 역할 (Role)

### `KEY WORD`: 역할과 계정은 논리적 분리, 물리적 동일

## (1) 특징

- 역할을 만들고 그 역할이 수행할 수 있는 권한을 설정하지 않는다면, 역할은 그저 빈 껍데기가 된다. 마치 활성화된 서버가 올라가지 않은 VPC 와 같다.
- 역할별로 권한 설정을 꼭 해줘야 한다.

## (2) 역할과 계정의 관계

역할은 계정이 쓸 수 있는 도구이다. 
계정마다 `SET ROLE`을 활용하여 어떤 역할을 할 수 있는지 정해야 한다. 이는 DB를 재부팅할 때마다 초기화되며, 이것이 싫다면 `active_all_roles_on_login=ON`으로 초기화되지 않도록 설정해야 한다. 

  위 키워드에서도 말했듯이 역할과 계정은 논리적으로는 분리되어 있으나 물리적으로는 동일하다. 이것이 무슨 말이냐면 역할 또한 **계정 취급을 받으며 계정 테이블에 들어가 있다는 것이다.**

![image-20250305195932322](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/User&Privilege/image-20250305195932322.png)

### Q1. 그럼 뭐가 유저고 뭐가 역할인지 어떻게 구분하나요? 

구분할 필요 없음! 

![image-20250305201908984](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/User&Privilege/image-20250305201908984.png)

유저는 어짜피 USER라는 계정으로만 로그인 및 접속이 가능하다.  따라서 사실 유저는 ROLE을 같은 유저 객체라 인지해야하는 순간이 없음!

### Q2. `SET ROLE`은 어떻게 동작하나요? 

필자는 이렇게 착각했다.

![image-20250305205504323](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/User&Privilege/image-20250305205504323.png)

위 사진과 같이 계정이 ROLE을 바라보고 있는 `경로 지정형`이라 생각했지만, MySQL 내부 구조는 권한 병합 형태로 이루어진다. 즉 유저 객체 안으로 권한을 뜻하는 객체가 포함된다.

![image-20250305205612894](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/User&Privilege/image-20250305205612894.png)

### Q3. 그러면 역할을 뜻하는 객체의 접속지점은 어디에 쓰이나요? 

역할을 뜻하는 객체 또한 물리적으로는 유저 테이블에 들어있기 때문에  `이름` + `@` + `유효한 접속 지점` 형태로 명명 되어 있다. 하지만 뒤에 유효한 접속 지점은 의미 없는 값이고, 항상 `% (모든 지점에서 사용 가능)` 이 붙어 있는 것이다. 

------

참고 주석

[^스토어드 프로그램이란?]: 스토어드 프로그램의 종류는 3가지로, 스토어드 프로시저, 스토어드 함수, 트리거가 있음 (스토어드 프로시저는 특정 작업을 수행하는 함수, 스토어드 함수는 말 그대로 특정 값을 반환하는 함수, 스토어드 트리거는 데이터 변경이 일어날 때 자동으로 실행되는 프로그램) `DEFINER`는 해당 프로그램을 생성한 사람이다. 이는 사용자 계정으로는 임의로 못 바꾸지만 시스템 계정은 가능
[^SSL]: Secure Socket Layer은 인터넷에서 데이터를 암호화해서 안전하게 주고 받을 수 있도록 해주는 기술, 서버의 mySQL을 다른 접속 지점에서 접근하려 할 때, 어찌 되었든 네트워크를 거쳐야 하는데 SSL을 설정하지 않으면, 평문으로 주고 받아서 해커의 먹잇감이 된다.
