# 1. ë¬¸ì œ ì„¤ëª… ğŸ“Œ

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/2211)

ë¬¸ì œë¥¼ ë³´ë©°, ì°¾ì•„ë‚¸ ì¡°ê±´ì€ ë‹¤ìŒ `3`ê°€ì§€ ì˜€ë‹¤.

- 1ï¸âƒ£ ìµœì†Œ ê°œìˆ˜ì˜ íšŒì„ ì„ ë³µêµ¬í•˜ë¼
- 2ï¸âƒ£ ëª¨ë“  ì„œë¡œ ë‹¤ë¥¸ 2 ëŒ€ì˜ ì»´í“¨í„°ê°€ êµì‹ ì´ ê°€ëŠ¥í•´ì•¼ í•œë‹¤.
- 3ï¸âƒ£ ìŠˆí¼ ì»´í“¨í„°ì—ì„œ ë‹¤ë¥¸ ì»´í“¨í„°ë¡œì˜ í†µì‹  ìµœì†Œ ë¹„ìš©ì€ ë³µêµ¬ ì´ì „ê³¼ ê°™ì•„ì•¼ í•œë‹¤.

  ë¬¸ì œë¥¼ í’€ë©° ëŠë‚€ ì ì€, 
3ï¸âƒ£ ë•Œë¬¸ì— 1ï¸âƒ£ì€ ìˆìœ¼ë‚˜ ë§ˆë‚˜ í•œ ì¡°ê±´ì´ ë˜ì—ˆë‹¤. 3ï¸âƒ£ì„ ë§Œì¡±ì‹œí‚¤ë ¤ë©´ **`ë‹¤ìµìŠ¤íŠ¸ë¼`**ë¥¼ í™œìš©í•´ì„œ, ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì•„ì•¼ í•˜ê³ , ê·¸ ìµœë‹¨ ê²½ë¡œì— ì‚¬ìš©ëœ íšŒì„ ë³´ë‹¤ ê°œìˆ˜ë¥¼ ë” ì¤„ì¼ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤. (ì¤„ì´ë©´, ì–´ë–¤ ì»´í“¨í„°ì—ëŠ” ìŠˆí¼ì»´í“¨í„°ê°€ ë„ë‹¬í•˜ì§€ ëª»í•œë‹¤.)  2ï¸âƒ£ ë˜í•œ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ í™œìš©í•˜ë©´, **ìµœì†Œ ìŠˆí¼ ì»´í“¨í„°ë¥¼ ë§¤ê°œë¡œ ëª¨ë‘ êµì‹ í•  ìˆ˜ ìˆê¸°ì—** ë”°ë¡œ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ì¡°ê±´ì´ ì•„ë‹ˆë‹¤. ë”°ë¼ì„œ **ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ í•˜ë©° ê±°ì³ê°€ ê²½ë¡œë¥¼ ê¸°ì–µí•˜ëŠ” ë¬¸ì œ**ì´ë‹¤.



# 2. êµ¬í˜„ ë°©ë²• ğŸ—ƒï¸

**`KEY WORD`: `DIJKSTRA`**

- 0ï¸âƒ£ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ ìš© í´ë˜ìŠ¤ì¸ **`Node`**ì™€ ë‹¤ìµìŠ¤íŠ¸ë¼ìš© í´ë˜ìŠ¤ì¸ **`Dist`**ë¥¼ ë‚˜ëˆ ì„œ êµ¬í˜„í•œë‹¤. 
  - ì´ë•Œ **DIST**ì—ëŠ” ê±°ì³ì˜¨ ê°„ì„  ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” `HashSet<Edge> edge`ë¥¼ êµ¬í˜„í•´ ë†“ëŠ”ë‹¤.
  - `HashSet<Edge> edge`ëŠ” **HashMapì˜ ë™ë“±ì„±**ì„ ìœ„í•˜ì—¬ hashCodeì™€ equalsë¥¼ overrideí•˜ì—¬ êµ¬í˜„í•´ ë†“ëŠ”ë‹¤.
  - **ìµœë‹¨ê±°ë¦¬ ë°°ì—´**ë„ `Dist`ë¥¼ ìë£Œí˜•ìœ¼ë¡œ êµ¬í˜„í•œë‹¤.
- 1ï¸âƒ£ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ì§„í–‰í•œë‹¤. ìµœë‹¨ ê±°ë¦¬ ë°°ì—´ì˜ `dist(ë„ì°©ì§€ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬)`ê°€ ê°±ì‹ ë  ë•Œë§ˆë‹¤, ìµœë‹¨ ê±°ë¦¬ ë°°ì—´ì˜ `Edge Set`ë„ ê°±ì‹ í•œë‹¤. (ë§Œì•½ `dist[B] > dist[A] + A âœ Bì˜ ê°„ì„  ë¹„ìš©` ìœ¼ë¡œ ê°±ì‹ ë˜ì—ˆë‹¤ë©´, `dist[B].edge`ëŠ” ì›ë˜ ê°’ì€ ë¹„ìš°ê³ , `dist[A].edge` + `new Edge(A, B)`ë¡œ ì±„ìš´ë‹¤.)
- 2ï¸âƒ£ë‹¤ìµìŠ¤íŠ¸ë¼ê°€ ëë‚œ ë’¤ì—ëŠ” ìµœë‹¨ ê±°ë¦¬ ë°°ì—´ì„ ëŒë©°, ëª¨ë“  Edgeë¥¼ ì „ì²´ HashSetì— ë„£ëŠ”ë‹¤. (ì¤‘ë³µ ì œê±° + ëª¨ë“  ê°„ì„ ì„ í•œ ê³³ì— ì €ì¥)
- 3ï¸âƒ£ ì „ì²´ HashSetì˜ Sizeì™€ ê° ê°„ì„ ì„ ì¶œë ¥í•œë‹¤.

## (1) ì‹œê°„ë³µì¡ë„ ë¶„ì„ ğŸ•“

ì •ì ì˜ ìˆ˜ë¥¼ `V`, ê°„ì„ ì˜ ìˆ˜ë¥¼ `E`ë¼ê³  í•  ë•Œ, 
ê¸°ë³¸ ë‹¤ìµìŠ¤íŠ¸ë¼ ì‹œê°„ ë³µì¡ë„ $O(V \log E)$ 

+ ì²« ë°˜ë³µì—ëŠ” ìµœëŒ€ 0ê°œì˜ ê°„ì„ ì„ ì‚­ì œí•˜ê³ , ìµœëŒ€ 1 ê°œì˜ ê°„ì„ ì„ ì‚½ì…í•œë‹¤.
+ ë‘ ë²ˆì§¸ ë°˜ë³µì—ëŠ” ìµœëŒ€ 1ê°œì˜ ê°„ì„ ì„ ì‚­ì œí•˜ê³ , ìµœëŒ€ 2ê°œì˜ ê°„ì„ ì„ ì‚½ì…í•œë‹¤.
+ ...
+ `V`ë²ˆì§¸ ë°˜ë³µì—ëŠ” ìµœëŒ€ $V-1$ê°œì˜ ê°„ì„ ì„ ì‚­ì œí•˜ê³ , $V$ê°œì˜ ê°„ì„ ì„ ì‚½ì…í•œë‹¤.

ì´ $O(V^{2})$

ì¦‰ $O(V \log E) + O(V^{2})$ ë¡œ ì‹œê°„ë³µì¡ë„ëŠ” $O(V^{2})$ ë‹¤. 

ë‚´ í’€ì´ê°€ í†µê³¼í•œ ì´ìœ ëŠ” ì•„ë§ˆ, ì •ì ì˜ ê°œìˆ˜ê°€ ìµœëŒ€ 1000ê°œë¼ì„œ ì¸ ê²ƒ ê°™ë‹¤.

# 3. ì½”ë“œ ì†Œê°œ ğŸ”

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.StringTokenizer;


public class Main {
    static int N,M;
    static ArrayList<Node> [] lists;
    static Dist [] dists;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st= new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        lists = new ArrayList[N + 1];

        for (int i = 1; i < N + 1; i++) {
            lists[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int start   = Integer.parseInt(st.nextToken());
            int end     = Integer.parseInt(st.nextToken());
            int weight  = Integer.parseInt(st.nextToken());

            lists[start].add(new Node(end, weight));
            lists[end].add(new Node(start, weight));
        }
        dijkstra();
        HashSet<Edge> sum = new HashSet<>();
        StringBuilder ans = new StringBuilder();

        for (int i = 1; i < N + 1; i++) {
            sum.addAll(dists[i].routes);
        }
        ans.append(sum.size()).append("\n");
        for (Edge now : sum){
            ans.append(now.start).append(" ").append(now.end).append("\n");
        }
        System.out.println(ans.toString());
    }

    public static void dijkstra () {
        dists = new Dist[N + 1];
        for (int i = 1; i < N + 1; i++) {
            dists[i] = new Dist(i);
        }
        dists[1].dist = 0;

        PriorityQueue<Dist> pq = new PriorityQueue<>(Comparator.comparingInt(o -> o.dist));
        pq.add(new Dist(1,0));

        while(!pq.isEmpty()){
            Dist now = pq.poll();

            if(now.dist != dists[now.idx].dist) continue;

            for (int i = 0; i < lists[now.idx].size(); i++) {
                Node next = lists[now.idx].get(i);
                if(dists[next.idx].dist > dists[now.idx].dist + next.w) {
                    dists[next.idx].dist = dists[now.idx].dist + next.w;
                    dists[next.idx].routes.clear();
                    dists[next.idx].routes.addAll(dists[now.idx].routes);
                    dists[next.idx].routes.add(new Edge(now.idx, next.idx));
                    pq.add(new Dist(next.idx, dists[next.idx].dist, dists[next.idx].routes));
                }
            }
        }
    }
}

class Dist {
    int idx;
    int dist;
    HashSet<Edge> routes;

    public Dist (int i) {
        this.idx = i;
        this.dist = Integer.MAX_VALUE;
        routes = new HashSet<>();
    }

    public Dist (int i, int dist){
        this.idx = i;
        this.dist = dist;
    }

    public Dist (int i, int dist, HashSet<Edge> prev){
        this.idx = i;
        this.dist = dist;
        routes = new HashSet<>();
        routes.addAll(prev);
    }

    public String toString() {
        return "[" + idx + ", " + dist + ", " + routes + "]";
    }
}


class Node {
    int idx;
    int w;

    public Node (int idx, int w) {
        this.idx = idx;
        this.w = w;
    }
}

class Edge {
    int start;
    int end;

    public Edge (int start, int end) {
        this.start = start;
        this.end = end;
    }

    @Override
    public int hashCode(){
        return this.start + this.end;
    }

    @Override
    public boolean equals(Object obj) {
        if(obj.getClass() != this.getClass()) return false;
        Edge o = (Edge) obj;
        return o.start == this.start && o.end == this.end;
    }
}

```

# 4. ë°°ìš´ ê²ƒë“¤ ğŸ¯

ì²« í’€ì´ëŠ” ë§Œì•½ **'í›„ì— ê³„ì‚°í•œ ìµœë‹¨ ê±°ë¦¬ ê°€ì¤‘ì¹˜ê°€ ê°™ìœ¼ë©´, ê°„ì„ ì„ ì ê²Œ ì“´ ë…€ì„ìœ¼ë¡œ distë¥¼ ê°±ì‹ í•œë‹¤'**ëŠ” ì˜ë¯¸ì˜ ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤. í•˜ì§€ë§Œ, í•´ë‹¹ ì½”ë“œëŠ” ë¬´ì˜ë¯¸í•˜ê²Œ ê³„ì‚° ì‹œê°„ë§Œ ì¡ì•„ë¨¹ëŠ” ì½”ë“œì´ë‹¤. ì™œëƒí•˜ë©´, **ë¬´ìŠ¨ ê²½ë¡œ**ë¥¼ ì“°ë“  ì‚¬ìš©ëœ ì „ì²´ ê°„ì„ ì˜ ê°œìˆ˜ì— ì–´ì§œí”¼ 1ê°œë§Œ ë”í•´ì§€ê¸° ë•Œë¬¸ì´ë‹¤. 

![image-20250117234351671](../../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/[ë°±ì¤€] 2211 ë„¤íŠ¸ì›Œí¬ ë³µêµ¬/image-20250117234351671.png)

í•´ë‹¹ ì˜ˆì‹œì—ì„œëŠ” B,Cê°€ ë¨¼ì € ë°©ë¬¸ ë  ê²ƒì´ê³ , ë‹¤ìŒì€ Aë¥¼ ë°©ë¬¸í•  ì°¨ë¡€ë‹¤. ìš°ì„ ìˆœìœ„ í êµ¬í˜„ì— ë”°ë¼ì„œ ì¶œë°œì§€ì—ì„œ ë°”ë¡œ Aë¡œ ê°€ëŠ”  3ì´ ë¨¼ì € ëœ¨ê² ì§€ë§Œ, ìš°ë¦¬ëŠ” 1 âœ  1 âœ 1ì´ ë¨¼ì € íì—ì„œ ë‚˜ì˜¤ê³  ë’¤ì— ê°„ì„  1ê°œ ì§œë¦¬ 3ì´ íì—ì„œ ë‚˜ì˜¨ë‹¤ê³  í•´ë³´ì.

```java
                if(dists[next.idx].dist == dists[now.idx].dist + next.w &&
                    dists[next.idx].routes.size() > dists[now.idx].routes.size() + 1) {
                    dists[next.idx].routes.clear();
                    dists[next.idx].routes.addAll(dists[now.idx].routes);
                    dists[next.idx].routes.add(new Edge(now.idx, next.idx));
                }
```

ê·¸ë ¤ë©´ ë‚´ê°€ ì ì€ í•´ë‹¹ ì½”ë“œì— ë”°ë¼, (ì¶œë°œì§€,B)âœ (B,C) âœ (C,A)ì€ íê¸° ë˜ê³  (ì¶œë°œì§€,A)ë¡œ dist[A]ëŠ” ê°±ì‹ ë  ê²ƒì´ë‹¤. ê·¼ë° ë‚˜ì¤‘ì— í•©ì¹˜ë©´, ë‘ ê²½ìš°ì˜ ìˆ˜ ëª¨ë‘ ê°„ì„ ì€ 3ê°œë§Œ ì‚¬ìš©í•œë‹¤. 
[A, B], [B, C]. [C, A] ì´ë“ , [A,B], [B,C], [A,C] ì´ë“  ë§ì´ë‹¤.