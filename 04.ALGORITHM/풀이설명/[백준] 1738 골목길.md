# 1. ë¬¸ì œ ì„¤ëª… ğŸ“Œ

## (1) ë§í¬ğŸ”—

https://www.acmicpc.net/problem/1738



## (2) í•´ì„¤ğŸ•µ

ê²½ë¡œì— ê¹¡íŒ¨ê°€ ìˆì–´ì„œ ê°€ì¤‘ì¹˜ê°€ **`ë§ˆì´ë„ˆìŠ¤`**ì¸ ê²½ìš°ê°€ ìˆë‹¤. ë”°ë¼ì„œ ìµœì  ê²½ë¡œëŠ” **`ë²¨ë§Œ í¬ë“œ`**ë¡œ êµ¬í•´ì•¼ í•˜ëŠ”ë°, ì—¬ê¸°ì— ì œì•½ ì¡°ê±´ì´ ìˆë‹¤.

- 1ï¸âƒ£ ì´ë²ˆ ë¬¸ì œëŠ” ìµœì†Œ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì  ê²½ë¡œì¸ ì¼ë°˜ì ì¸ ë²¨ë§Œ í¬ë“œ ë¬¸ì œì™€ëŠ” ë‹¬ë¦¬ <u>ìµœëŒ€ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì  ê²½ë¡œ</u> ì´ë‹¤.
- 2ï¸âƒ£ ë”°ë¼ì„œ ìµœì  ê²½ë¡œë¥¼ êµ¬í•  ìˆ˜ ì—†ëŠ” ê²½ìš°ëŠ” N ë²ˆì§¸ ì™„í™”ê³¼ì •ì„ ê±°ì³ë„ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ì»¤ì§€ëŠ” ê²½ë¡œê°€ ìˆëŠ” ê²½ìš°ì´ë‹¤.
- 3ï¸âƒ£í•˜ì§€ë§Œ <u>ì–‘ì˜ ì‚¬ì´í´ì´ 1ì—ì„œ Nê¹Œì§€ì˜ ê²½ë¡œì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ”ë‹¤ë©´, ìµœì  ê²½ë¡œëŠ” ê·¸ëŒ€ë¡œ ì¡´ì¬í•˜ëŠ” ê²ƒì„ìœ¼ë¡œ ìƒê´€ ì—†ë‹¤.</u>

# 2. ìƒê°ì˜ íë¦„: ì½”ë“œê°€ ë‚˜ì˜¤ê¸°ê¹Œì§€ ğŸ—ƒï¸

## (1) IDEA ë„ì¶œğŸ’¡

**`KEY WORD`: `Bellman-ford`, `BFS`**

í•´ì„¤ì—ì„œì˜ 3ë²ˆ **ì–‘ì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ë”ë¼ë„, 1ì—ì„œ Nê¹Œì§€ ê°€ëŠ” ê²½ë¡œ ì¤‘ ì–´ëŠ í•˜ë‚˜ì—ë„ ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ”ë‹¤ë©´, ìµœì  ê²½ë¡œëŠ” ì¡´ì¬í•˜ëŠ” ê²ƒì„ìœ¼ë¡œ ìƒê´€ ì—†ë‹¤.**ë¥¼ ì–´ë–»ê²Œ êµ¬í˜„í• ì§€ê°€ ê´€ê±´ ì´ì—ˆë‹¤.

ì–‘ì˜ ì‚¬ì´í´ì„ ë°œê²¬í•œë‹¤ë©´, Nì—ê²Œ ë‹¿ëŠ”ì§€ë§Œ í™•ì¸í•´ì£¼ë©´ ëœë‹¤. í•„ìëŠ” ì–‘ì˜ ì‚¬ì´í´ì„ ë°œê²¬í•  ì‹œ, **ì–‘ì˜ ì‚¬ì´í´ì´ ì¡´ì¬í–ˆë˜ ì •ì ì—ì„œ Në²ˆ ì •ì ê¹Œì§€ BFSë¡œ ë‹¿ëŠ”ì§€ë¥¼ í™•ì¸**í–ˆë‹¤.

ë”°ë¼ì„œ ì´ë²ˆ ë¬¸ì œì—ì„œ í•„ìš”í•œ ìë£Œêµ¬ì¡°ëŠ”

- 1ï¸âƒ£ ê°„ì„  ë¦¬ìŠ¤íŠ¸
- 2ï¸âƒ£ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸
- 3ï¸âƒ£ ê±°ë¦¬ ë°°ì—´
- 4ï¸âƒ£ to - from ë°°ì—´ (ìê¸° ë¿Œë¦¬ ì°¾ê¸° ë°°ì—´: ìì‹ ì—ê²Œ ì˜¤ëŠ” ì •ì ì„ ì €ì¥)

ì´ ë˜ê² ë‹¤.

## (2) SUDO CODE ğŸ“œ

- 0ï¸âƒ£ ìœ„ì— ì œì‹œí•œ 4ê°€ì§€ ìë£Œêµ¬ì¡° ì„ ì–¸ê³¼ ì´ˆê¸°í™”
- 1ï¸âƒ£ ë²¨ë§Œí¬ë“œë¥¼ N-1ë²ˆê¹Œì§€ ì§„í–‰ (dist ë°°ì—´ ì±„ìš°ë©´ì„œ from-to ë°°ì—´ë„ ì±„ìš°ê¸°)
- 2ï¸âƒ£ ì–‘ìˆ˜ ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
- 3ï¸âƒ£ ì–‘ìˆ˜ ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ë©´, í˜„ ë…¸ë“œë¶€í„° BFSí•˜ì—¬ Në²ˆ ì •ì ì— ë‹¿ëŠ”ì§€ í™•ì¸
- 4ï¸âƒ£ ë‹¿ìœ¼ë©´ ìµœì  ê²½ë¡œê°€ ë  ìˆ˜ ì—†ëŠ” ì…ë ¥ì„ìœ¼ë¡œ `-1`ì„ ì¶œë ¥
- 5ï¸âƒ£ 2ë²ˆì˜ ìŒìˆ˜ ì‚¬ì´í´ì´ ì—†ìœ¼ë©´ 

## (3) ì‹œê°„ë³µì¡ë„ ë¶„ì„ ğŸ•“

ì •ì ì˜ ê°œìˆ˜ `N`(ìµœëŒ€ 20,000), ê°„ì„ ì˜ ê°œìˆ˜ `E` (100)

  ì‹œê°„ ë³µì¡ë„: N-1ë²ˆ ì™„í™” + ìŒìˆ˜ ì‚¬ì´í´ í™•ì¸í•˜ë©° BFSë¡œ Në²ˆ ì •ì  í™•ì¸í•˜ê¸° 
O(20,000 * 100 + (20,100)) ì‹œê°„ë³µì¡ë„ëŠ” $10^8$ë³´ë‹¤ ì‘ë‹¤

# 3. êµ¬í˜„ ì½”ë“œ ğŸ”

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main {
    public static void main(String[] args) throws IOException {
        Solution solution = new Solution();
        solution.solution();
    }
}

class Solution {
    static int N, M;
    static int [][] edge_list;
    static ArrayList<Node> [] lists;
    static int [] dists, temp;
    static int [] where_are_you_from;
    static class Node {
        int end;
        int weight;

        public Node (int end, int weight) {
            this.end = end;
            this.weight = weight;
        }
    }

    public void solution () throws  IOException {
        input();
        if (!bellman_ford()) {
            System.out.println(-1);
            return;
        }
        StringBuilder sb = new StringBuilder();
        int i = N;
        while (i != 0) {
            sb.insert(0, i).insert(0, " ");
            i = where_are_you_from[i];
        }
        String answer = sb.toString().trim();
        System.out.println(answer);
    }
    public void input () throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        dists = new int [N+1];
        lists = new ArrayList [N+1];
        for (int i = 1; i <= N; i++) {
            lists[i] = new ArrayList<>();
        }
        edge_list = new int[M][3];
        where_are_you_from = new int [N+1];
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int start   = Integer.parseInt(st.nextToken());
            int end     = Integer.parseInt(st.nextToken());
            int weight  = Integer.parseInt(st.nextToken());
            edge_list[i] = new int [] {start, end, weight};
            lists[start].add(new Node( end, weight));
        }
        Arrays.sort(edge_list, (a,b) -> {
            if(a[0] == b[0]) {
                if(a[1] == b[1]) return a[2] - b[2];
                return a[1] - b[1];
            }
            return a[0] - b[0];
        });
    }

    public boolean bellman_ford () {
        Arrays.fill(dists, -(Integer.MAX_VALUE - 1));
        dists[1] = 0;
        for (int i = 0; i < N; i++) mitigation();
        return is_cycle_and_go_to_N();
    }

    public void mitigation () {
        for (int j = 0; j < M; j++) {
            int start   = edge_list[j][0];
            int end     = edge_list[j][1];
            int weight  = edge_list[j][2];
            if(dists[start] == - (Integer.MAX_VALUE - 1)) continue;
            if(dists[start] + weight > dists[end]) {
                dists[end]  = dists[start] + weight;
                where_are_you_from[end] = start;
            }
        }
//        System.out.println(Arrays.toString(dists));
    }

    public boolean is_cycle_and_go_to_N(){
        for (int j = 0; j < M; j++) {
            int start   = edge_list[j][0];
            int end     = edge_list[j][1];
            int weight  = edge_list[j][2];
            if(dists[start] == - (Integer.MAX_VALUE - 1)) continue;
            if(dists[start] + weight > dists[end]) {
                if(!bfs(start)) return false;
            }
        }
        return true;
    }

    public boolean bfs (int target_vertex) {
        boolean [] isVisited = new boolean[N + 1];
        ArrayDeque<Node> aq1 = new ArrayDeque<>();
        aq1.add(new Node(target_vertex, 0));
        isVisited[target_vertex] = true;

        while (!aq1.isEmpty()){
            int qSize = aq1.size();
            for (int i = 0; i < qSize; i++) {
                Node now = aq1.poll();
                for (int j = 0; j < lists[now.end].size(); j++) {
                    Node next = lists[now.end].get(j);
                    if(!isVisited[next.end]){
                        if(next.end == N) return false;
                        aq1.add(next);
                        isVisited[next.end] = true;
                    }
                }
            }
        }
        return true;
    }
}
```



# 4. ë°°ìš´ ê²ƒë“¤ ğŸ¯

**`from-to ë°°ì—´`**ì— ëŒ€í•´ ë°°ìš°ê²Œ ë˜ì–´ ì¢‹ì•˜ë‹¤. 
ì²˜ìŒì—ëŠ” Në²ˆì—ì„œ BFSë¥¼ ëŒë¦¬ë©° ì¸ì ‘ ì •ì ë“¤ì—ê²Œ ì‚¬ì´í´ì´ ìˆëŠ”ì§€ í™•ì¸í–ˆëŠ”ë°, ì´ê²ƒì´ ì‹œê°„ì´ˆê³¼ë¥¼ ì´ˆë˜í•œ ê±° ê°™ë‹¤.

